// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "proto/demeter/ops/v1alpha/usage.proto" (package "demeter.ops.v1alpha", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message demeter.ops.v1alpha.UsageReport
 */
export interface UsageReport {
    /**
     * @generated from protobuf field: string resource_id = 1
     */
    resourceId: string;
    /**
     * @generated from protobuf field: string resource_name = 2
     */
    resourceName: string;
    /**
     * @generated from protobuf field: string resource_kind = 3
     */
    resourceKind: string;
    /**
     * @generated from protobuf field: string resource_spec = 4
     */
    resourceSpec: string;
    /**
     * @generated from protobuf field: int64 units = 5
     */
    units: bigint;
    /**
     * @generated from protobuf field: string tier = 7
     */
    tier: string;
    /**
     * @generated from protobuf field: string period = 8
     */
    period: string;
    /**
     * @generated from protobuf field: optional double units_cost = 9
     */
    unitsCost?: number;
    /**
     * @generated from protobuf field: optional double minimum_cost = 10
     */
    minimumCost?: number;
}
/**
 * @generated from protobuf message demeter.ops.v1alpha.FetchUsageReportRequest
 */
export interface FetchUsageReportRequest {
    /**
     * @generated from protobuf field: string project_id = 1
     */
    projectId: string;
    /**
     * @generated from protobuf field: optional uint32 page = 2
     */
    page?: number;
    /**
     * @generated from protobuf field: optional uint32 page_size = 3
     */
    pageSize?: number;
    /**
     * @generated from protobuf field: optional string cluster_id = 4
     */
    clusterId?: string;
}
/**
 * @generated from protobuf message demeter.ops.v1alpha.FetchUsageReportResponse
 */
export interface FetchUsageReportResponse {
    /**
     * @generated from protobuf field: repeated demeter.ops.v1alpha.UsageReport records = 1
     */
    records: UsageReport[];
}
/**
 * @generated from protobuf message demeter.ops.v1alpha.FetchUsageClusterRequest
 */
export interface FetchUsageClusterRequest {
    /**
     * @generated from protobuf field: string project_id = 1
     */
    projectId: string;
    /**
     * @generated from protobuf field: optional uint32 page = 2
     */
    page?: number;
    /**
     * @generated from protobuf field: optional uint32 page_size = 3
     */
    pageSize?: number;
}
/**
 * @generated from protobuf message demeter.ops.v1alpha.FetchUsageClusterResponse
 */
export interface FetchUsageClusterResponse {
    /**
     * @generated from protobuf field: repeated string clusters = 1
     */
    clusters: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class UsageReport$Type extends MessageType<UsageReport> {
    constructor() {
        super("demeter.ops.v1alpha.UsageReport", [
            { no: 1, name: "resource_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resource_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resource_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "resource_spec", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "units", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "period", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "units_cost", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "minimum_cost", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<UsageReport>): UsageReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourceId = "";
        message.resourceName = "";
        message.resourceKind = "";
        message.resourceSpec = "";
        message.units = 0n;
        message.tier = "";
        message.period = "";
        if (value !== undefined)
            reflectionMergePartial<UsageReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsageReport): UsageReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resource_id */ 1:
                    message.resourceId = reader.string();
                    break;
                case /* string resource_name */ 2:
                    message.resourceName = reader.string();
                    break;
                case /* string resource_kind */ 3:
                    message.resourceKind = reader.string();
                    break;
                case /* string resource_spec */ 4:
                    message.resourceSpec = reader.string();
                    break;
                case /* int64 units */ 5:
                    message.units = reader.int64().toBigInt();
                    break;
                case /* string tier */ 7:
                    message.tier = reader.string();
                    break;
                case /* string period */ 8:
                    message.period = reader.string();
                    break;
                case /* optional double units_cost */ 9:
                    message.unitsCost = reader.double();
                    break;
                case /* optional double minimum_cost */ 10:
                    message.minimumCost = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UsageReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resource_id = 1; */
        if (message.resourceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resourceId);
        /* string resource_name = 2; */
        if (message.resourceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceName);
        /* string resource_kind = 3; */
        if (message.resourceKind !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resourceKind);
        /* string resource_spec = 4; */
        if (message.resourceSpec !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.resourceSpec);
        /* int64 units = 5; */
        if (message.units !== 0n)
            writer.tag(5, WireType.Varint).int64(message.units);
        /* string tier = 7; */
        if (message.tier !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.tier);
        /* string period = 8; */
        if (message.period !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.period);
        /* optional double units_cost = 9; */
        if (message.unitsCost !== undefined)
            writer.tag(9, WireType.Bit64).double(message.unitsCost);
        /* optional double minimum_cost = 10; */
        if (message.minimumCost !== undefined)
            writer.tag(10, WireType.Bit64).double(message.minimumCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message demeter.ops.v1alpha.UsageReport
 */
export const UsageReport = new UsageReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchUsageReportRequest$Type extends MessageType<FetchUsageReportRequest> {
    constructor() {
        super("demeter.ops.v1alpha.FetchUsageReportRequest", [
            { no: 1, name: "project_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "page_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cluster_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FetchUsageReportRequest>): FetchUsageReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.projectId = "";
        if (value !== undefined)
            reflectionMergePartial<FetchUsageReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchUsageReportRequest): FetchUsageReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string project_id */ 1:
                    message.projectId = reader.string();
                    break;
                case /* optional uint32 page */ 2:
                    message.page = reader.uint32();
                    break;
                case /* optional uint32 page_size */ 3:
                    message.pageSize = reader.uint32();
                    break;
                case /* optional string cluster_id */ 4:
                    message.clusterId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchUsageReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string project_id = 1; */
        if (message.projectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.projectId);
        /* optional uint32 page = 2; */
        if (message.page !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.page);
        /* optional uint32 page_size = 3; */
        if (message.pageSize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.pageSize);
        /* optional string cluster_id = 4; */
        if (message.clusterId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.clusterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message demeter.ops.v1alpha.FetchUsageReportRequest
 */
export const FetchUsageReportRequest = new FetchUsageReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchUsageReportResponse$Type extends MessageType<FetchUsageReportResponse> {
    constructor() {
        super("demeter.ops.v1alpha.FetchUsageReportResponse", [
            { no: 1, name: "records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UsageReport }
        ]);
    }
    create(value?: PartialMessage<FetchUsageReportResponse>): FetchUsageReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.records = [];
        if (value !== undefined)
            reflectionMergePartial<FetchUsageReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchUsageReportResponse): FetchUsageReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated demeter.ops.v1alpha.UsageReport records */ 1:
                    message.records.push(UsageReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchUsageReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated demeter.ops.v1alpha.UsageReport records = 1; */
        for (let i = 0; i < message.records.length; i++)
            UsageReport.internalBinaryWrite(message.records[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message demeter.ops.v1alpha.FetchUsageReportResponse
 */
export const FetchUsageReportResponse = new FetchUsageReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchUsageClusterRequest$Type extends MessageType<FetchUsageClusterRequest> {
    constructor() {
        super("demeter.ops.v1alpha.FetchUsageClusterRequest", [
            { no: 1, name: "project_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "page_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FetchUsageClusterRequest>): FetchUsageClusterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.projectId = "";
        if (value !== undefined)
            reflectionMergePartial<FetchUsageClusterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchUsageClusterRequest): FetchUsageClusterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string project_id */ 1:
                    message.projectId = reader.string();
                    break;
                case /* optional uint32 page */ 2:
                    message.page = reader.uint32();
                    break;
                case /* optional uint32 page_size */ 3:
                    message.pageSize = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchUsageClusterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string project_id = 1; */
        if (message.projectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.projectId);
        /* optional uint32 page = 2; */
        if (message.page !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.page);
        /* optional uint32 page_size = 3; */
        if (message.pageSize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message demeter.ops.v1alpha.FetchUsageClusterRequest
 */
export const FetchUsageClusterRequest = new FetchUsageClusterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchUsageClusterResponse$Type extends MessageType<FetchUsageClusterResponse> {
    constructor() {
        super("demeter.ops.v1alpha.FetchUsageClusterResponse", [
            { no: 1, name: "clusters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FetchUsageClusterResponse>): FetchUsageClusterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        if (value !== undefined)
            reflectionMergePartial<FetchUsageClusterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchUsageClusterResponse): FetchUsageClusterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string clusters */ 1:
                    message.clusters.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchUsageClusterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string clusters = 1; */
        for (let i = 0; i < message.clusters.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusters[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message demeter.ops.v1alpha.FetchUsageClusterResponse
 */
export const FetchUsageClusterResponse = new FetchUsageClusterResponse$Type();
/**
 * @generated ServiceType for protobuf service demeter.ops.v1alpha.UsageService
 */
export const UsageService = new ServiceType("demeter.ops.v1alpha.UsageService", [
    { name: "FetchUsageReport", options: {}, I: FetchUsageReportRequest, O: FetchUsageReportResponse },
    { name: "FetchUsageCluster", options: {}, I: FetchUsageClusterRequest, O: FetchUsageClusterResponse }
]);
